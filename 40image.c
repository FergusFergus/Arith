/*
 * Madeleine Street (mstree03) and Fergus Ferguson (mfergu05)
 * Comp 40 - Homework 4
 *
 * 40image.c
 *
 * Allows the user to compress and decompress ppm image files. Compressing a
 * file outputs a txt file comprised of a short header and a stream of
 * bitpacked integers containing values which represent a 2x2 group of pixels.
 * Decompressing takes in a file, formatted like the file generated by
 * compressing, and uses it to make a ppm file.
 */



#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "assert.h"
#include "compress40.h"
#include "pnm.h"
#include "YPbPr.h"
#include "PixBlock.h"
#include "DCTransform.h"
#include "CodedImg.h"


static void (*compress_or_decompress)(FILE *input) = compress40;


int main(int argc, char *argv[])
{
        int i;

        for (i = 1; i < argc; i++) {
                if (strcmp(argv[i], "-c") == 0) {
                        compress_or_decompress = compress40;
                } else if (strcmp(argv[i], "-d") == 0) {
                        compress_or_decompress = decompress40;
                } else if (*argv[i] == '-') {
                        fprintf(stderr, "%s: unknown option '%s'\n",
                                argv[0], argv[i]);
                        exit(1);
                } else if (argc - i > 2) {
                        fprintf(stderr, "Usage: %s -d [filename]\n"
                                "       %s -c [filename]\n",
                                argv[0], argv[0]);
                        exit(1);
                } else {
                        break;
                }
        }
        assert(argc - i <= 1);    /* at most one file on command line */
        if (i < argc) {
                FILE *fp = fopen(argv[i], "r");
                assert(fp != NULL);
                compress_or_decompress(fp);
                fclose(fp);
        } else {
                compress_or_decompress(stdin);
        }

        return EXIT_SUCCESS;
}

/*
 * function compress40
 * Parameters:
 *   - FILE * input - input file
 * Returns: None
 * Preconditions:
 *    - input is non-NULL
 * Does: Compresses a ppm image and prints the result to stdout.
 */
extern void compress40(FILE * input)
{
    assert(input != NULL);

    /* read in pnm */
    A2Methods_T methods = uarray2_methods_plain;
    Pnm_ppm source = Pnm_ppmread(input, methods);

    /* convert color space */
    YPbPr_img ypp = YPbPr_new(source);
    Pnm_ppmfree(&source);

    /* Block pixels */
    PixBlocked_img pixBlocks = PixBlock_new(ypp);
    YPbPr_free(ypp);

    /* Discrete cosine transform and quantization */
    DCT_img dct = DCT_newDCTImg(pixBlocks);
    PixBlock_free(pixBlocks);

    /* Bitpack */
    Coded_img compressed = Coded_new(dct);
    DCT_free(dct);

    /* output */
    Coded_print(stdout, compressed);
    Coded_free(compressed);
}

/*
 * function decompress40
 * Parameters:
 *      - FILE * input for the source of the compressed image to read in
 * Returns: Nothing
 * Does: Reads in a compressed image, decompresses it and prints it as a ppm
 *       to stdout.
 * Preconditions:
 *      - input != NULL
 */
extern void decompress40(FILE * input)
{
    assert(input != NULL);
    /* read in bitpacked values */
    Coded_img compressed = Coded_readin(input);

    /* Unpack words */
    DCT_img unpacked_words = Coded_newDCT(compressed);
    Coded_free(compressed);

    /* Inverse quantization and inverse discrete cosine transform */
    PixBlocked_img pixel_blocks = DCT_newPixBlockedImg(unpacked_words);
    DCT_free(unpacked_words);

    /* Convert color space */
    YPbPr_img component_vid = PixBlock_newYPP(pixel_blocks);
    PixBlock_free(pixel_blocks);

    /* output pnm */
    Pnm_ppm decompressed = YPbPr_newPnm(component_vid);
    YPbPr_free(component_vid);

    Pnm_ppmwrite(stdout, decompressed);
    Pnm_ppmfree(&decompressed);
}
